# Stundenprotokolle 12. Klasse 1. Halbjahr 

<img alt="Foto der Gruppe" align="right" alt="Bild der Gruppe" height="200px" width="135px" src="https://user-images.githubusercontent.com/88385654/144517233-30a5e82f-7035-4ed2-aa45-f1700086d5cc.jpg">

<p>
Stormarnschule 2021 
     
<img align="left" heigth="120px" width="120px" alt="Logo der Stormarnschule" src="https://user-images.githubusercontent.com/88385654/143951761-5bef3ad8-f6f8-4034-8314-8af063be444e.jpg">
     
Informatik, Bl

David Borgmann, Simon Rettmann
     
</p>
</br>
</br>

## Stundenübersicht
<table align="center">
     
<tr>
    <td> <a href="#Stundevom3.8.2021"> 1. Stunde vom 3.8.2021 </a></td>
    <td> <a href="#Stundevom4.8.2021"> 2. Stunde vom 4.8.2021 </a></td>
    <td><a href="#Stundevom10.8.2021"> 3. Stunde vom 10.8.2021 </a></td>
    <td><a href="#Stundevom11.8.2021"> 4. Stunde vom 11.8.2021 </a></td>
</tr>
<tr>
    <td><a href="#Stundevom24.8.2021"> 5. Stunde vom 24.8.2021 </a></td>
    <td><a href="#Stundevom31.8.2021"> 6. Stunde vom 31.8.2021 </a></td>
    <td><a href="#Stundevom1.9.2021"> 7. Stunde vom 1.9.2021 </a></td>
    <td><a href="#Stundevom7.9.2021"> 8. Stunde vom 7.9.2021 </a></td>
</tr>
<tr>
    <td><a href="#Stundevom8.9.2021"> 9. Stunde vom 8.9.2021 </a></td>
    <td><a href="#Stundevom14.9.2021"> 10. Stunde vom 14.9.2021 </a></td>
    <td><a href="#Stundevom15.9.2021"> 11. Stunde vom 15.9.2021 </a></td>
    <td><a href="#Stundevom21.9.2021"> 12. Stunde vom 21.9.2021 </a></td>
 </tr>
 <tr>
    <td><a href="#Stundevom22.9.2021"> 13. Stunde vom 22.9.2021 </a></td>
    <td><a href="#Stundevom28.9.2021"> 14. Stunde vom 28.9.2021 </a></td>
    <td><a href="#Stundevom29.9.2021"> 15. Stunde vom 29.9.2021 </a></td>
    <td><a href="#Stundevom19.10.2021"> 16. Stunde vom 19.10.2021 </a></td>
 </tr>
 <tr>
    <td><a href="#Stundevom20.10.2021"> 17. Stunde vom 20.10.2021 </a></td>
    <td><a href="#Stundevom26.10.2021"> 18. Stunde vom 26.10.2021 </a></td>
    <td><a href="#Stundevom27.10.2021"> 19. Stunde vom 27.10.2021 </a></td>
    <td><a href="#Stundevom2.11.2021"> 20. Stunde vom 2.11.2021 </a></td>
</tr>
<tr>
    <td><a href="#Stundevom3.11.2021"> 21. Stunde vom 3.11.2021 </a></td>
    <td><a href="#Stundevom9.11.2021"> 22. Stunde vom 9.11.2021 </a></td>
    <td><a href="#Stundevom10.11.2021"> 23. Stunde vom 10.11.2021 </a></td>
    <td><a href="#Stundevom16.11.2021"> 24. Stunde vom 16.11.2021 </a></td>
</tr>
<tr>
    <td><a href="#Stundevom17.11.2021"> 25. Stunde vom 17.11.2021 </a></td>                           
    <td><a href="#Stundevom23.11.2021"> 26. Stunde vom 23.11.2021 </a></td>                      
    <td><a href="#Stundevom24.11.2021"> 27. Stunde vom 24.11.2021 </a></td>
    <td><a href="#Stundevom30.11.2021"> 28. Stunde vom 30.11.2021 </a></td>
</tr>
<tr>
    <td><a href="#Stundevom1.12.2021"> 29. Stunde vom 1.12.2021 </a></td>
    <td><a href="#Finalisierung"> Finalisierung des Projekts <br> vom 1.12.2021 - 6.12.2021 </a></td>
</tr>
    </table>

## <p> <h2> <a id="Stundevom3.8.2021"> Stunde vom 3.8.2021 </a> </h2>
In dieser ersten Informatikstunde des Schuljahres wurden die Erwartungen und der Ablauf des Kurses erklärt. Ein "GitHub" Account wurde angelegt und die Grundlagen gelegt. Gegen Ende der Stunde war außerdem noch Zeit vorhanden um sich bereits Gedanken über mögliche Projekte Gedanken zu machen. Allgemeiner Konsens war, dass es sich um ein arduinobasiertes "physical computing Projekt" handeln soll. Aufgrund eines Roboterkurses waren nämlich schon einige Mikrocontrollerkenntnisse vorhanden. Diskutierte Ideen waren ein adaptiv gesteuertet Eierkocher, ein regulierbarer und temperaturmessender Gaskocher und die Entwicklung eines Roboters, der Hindernisse wahrnimmt und auf diese reagiert. Nach Rücksprache mit Herrn Buhl wurde der regulierbare Gaskocher mit einigen Teilschritten ins Auge gefasst. Als Nachbereitung der Stunde wurden die Vorkenntnisse aufgefrischt und das bereits vorhandenen Material sortiert. Außerdem begann die Einarbeitungspahse in "GitHub" und "HTML". </p>

## <p> <h2> <a id="Stundevom4.8.2021"> Stunde vom 4.8.2021 </a> <h2>
Diese Informatikstunde startete mit der genaueren Planung und Aufgabenverteilung. Über einen gemeinsamen Leitfaden für die Stundenprotokolle wurde geredet. Anschließend wurden die Arduinokenntnisse weiter aufgefrischt. Die Gruppe startete mit dem Programmieren einer im Intervall blinkenden Lampe und begann an der Programmierung eines Potentiometers. Auch die Auswahl möglicher Gerätschaften stand auf der Tagesordnung. Im Fokus stand vor allem die Auswahl eines Thermometers.
  
Bei der leuchtenden Lampe handelt es sich um eine weiße Leuchtdiode, die durch den Arduino gesteuert wird. Die Lampe ist jeweils eine Sekunde an und anschließend ausgeschaltet. Um eine Zerstörung der Diode zu verhindern, wurde ein Widerstand in den Kreislauf gebaut. </p>

<details>
    <summary>Bildergalerie</summary>
  
<b>Steckplan für eine blinkende Leuchtdiode</b>
<img alt="Steckplan für eine blinkende Lampe" src="https://user-images.githubusercontent.com/88385654/129034053-222223fa-71a5-4461-b734-7e1efb53467b.png">
 
<b>Bild des Versuchsaufbaus mit eingeschalteter Leuchtdiode</b>
<img alt="Bild einer blinkenden Lampe" src="https://user-images.githubusercontent.com/88385654/128383828-eeb82b61-0753-48aa-b36b-35d966454e42.jpg"> 
</details>

    
<details>
    <summary>Arduino Code</summary>
    
```c
int LEDweiss = 7;

void setup() {

 pinMode(LEDweiss, OUTPUT);
}

void loop() {
  digitalWrite(LEDweiss, HIGH);
    delay(500);
  digitalWrite(LEDweiss, LOW);
    delay(500);                             
}
 ```
    
</details>
    
## <p> <h2> <a id="Stundevom10.8.2021"> Stunde vom 10.8.2021 </a> <h2>
In dieser Doppelstunde wurden die ersten Arduinocodes auf dem Weg zum Projekt geschrieben. Fokussiert wurde sich auf die Temperaturmessung und anschließende Steuerung einer Leuchtdiode. Besonders bei diesem Teilschritt war die Abhängigkeit von zwei nötigen Bedingungen für das leuchten der Lampe: Das Thermometer musste einen höheren Wert als 30 °C messen und zusätzlich musste der Knopf gedrückt werden. 

Als nächsten Schritt wurde eine Servosteuerung programmiert. Auch die Rotation des Servo-Motors war erneut von dem Thermometer und dem Drücken des Knopfes abhängig. Zudem wurde ein arduinofähiges Thermoelement, welches besonders hohe Temperatur messen kann, bestellt. Die selbstgewählte Hausaufgabe war sich mit einem "Stepper Motor" auseinanderzusetzen. Dieses Einlesen soll Grundlage für die nächste Stunde sein. </p>
    
<details>
    <summary>Code einer Lampe mit zwei Bedingungen</summary>
  
```c
    
int Knopfzustand;
int LEDpin = A1;
int ntc_pin = A0;
float R1 = 10000;

float temp_c;

void setup() {
  Serial.begin(9600);
  pinMode(2, INPUT);
}

void loop() {
// kopiert von: https://www.aeq-web.com/arduino-measure-temperature-with-ntc-resistor/ 
  float ain = analogRead(ntc_pin);                                                                          
  float R2 = R1 * (1023.0 / (float)ain - 1.0);
  float lgr = log(R2);
  float tmp = (1.0 / (1.009249522e-03 + 2.378405444e-04 * lgr + 2.019202697e-07 * lgr * lgr * lgr));
  temp_c = tmp - 273.15;
  
//ende Kopie  

  Serial.print("Temperature: ");
  Serial.print(temp_c);
  Serial.println(" C"); 
  delay(100);

Knopfzustand = digitalRead(2);

Serial.println (Knopfzustand);Monitor ein                                                                      
  if (temp_c > 30.00 && Knopfzustand ==1)                                                                
  {
    analogWrite(LEDpin, 255);
      delay(30);
  }
else {
      analogWrite(LEDpin, 0);
      delay(30);
```
    
</details>
    
<details>
    <summary>Code der Servosteuerung mit zwei Bedingungen</summary>
    
```c
    #include <Servo.h>

int Knopfzustand;
Servo myServo;
int ntc_pin = A0;                                                               
float R1 = 10000;                                                               

float temp_c;

void setup() {
  Serial.begin(9600);
  pinMode(2, INPUT);
  myServo.attach (3);
 
}

void loop() {
// kopiert von: https://www.aeq-web.com/arduino-measure-temperature-with-ntc-resistor/
  float ain = analogRead(ntc_pin);
  float R2 = R1 * (1023.0 / (float)ain - 1.0);
  float lgr = log(R2);
  float tmp = (1.0 / (1.009249522e-03 + 2.378405444e-04 * lgr + 2.019202697e-07 * lgr * lgr * lgr));
  temp_c = tmp - 273.15;
//ende Kopie  

  Serial.print("Temperature: ");
  Serial.print(temp_c);
  Serial.println(" C");
  delay(100);

Knopfzustand = digitalRead(2);

Serial.println (Knopfzustand);
  if (temp_c > 30.00 && Knopfzustand ==1) 
  {
    myServo.write(178);                                                        
      delay(1000);
  }
else {
      myServo.write(2);
      delay(1000);
      }
}
```
    
</details>
  
  ## <p> <h2> <a id="Stundevom11.8.2021"> Stunde vom 11.8.2021 </a> <h2>
Obwohl diese Informatikstunde leider aufallen musste, wurde diese dennoch genutz, um das Projetk nach vorne zu bringen. Um die Schaltpläne übersichtlicher darzustellen entschied sich das Team die Software "Fritzing" für die Erstelung digitaler Schaltpläne zu kaufen. "Fritzing" ermöglicht die Erstellung auf den Arduino zugeschnitte Schaltplanerstellung und hat viele Teile zu Verfügung. Link zu der Website von "Fritzing": https://fritzing.org/
Die Einarbeitung in dieses Programm begann und die Schaltung der blinkenden Lampe und der Servoschaltung wurden digitalisiert.
Der Rest der Zeit wurde genutzt um einen Schrittmotor zu verstehen und anzusteuern. Für erste Programmierungsversuche reichte die Zeit leider nicht auf. Dieser nächste Schritt soll von zu Hause erreicht werden.
  </p> 

<details>
    <summary>Screenshot von Fritzing</summary>
<b>Screenshot von Fritzing</b>       
<img alt="Screenshot von Fritzing" src="https://user-images.githubusercontent.com/88385654/129033788-4786fe85-1819-4c0e-94bd-8bf5a4296798.png">
 
</details>
    
  ## <p> <h2> <a id="Stundevom24.8.2021"> Stunde vom 24.8.2021 </a> <h2>
Die Ansteuerung des Schrittmotors klappte zu Beginn der Stunde. Mit einer passenden Library gelang es den Schrittmotor in verschiedenen Geschwindigkeiten sich um 360° zu drehen und anschließend in die andere Richtung zu drehen, bis der Startpunkt wieder erreicht wurde. 
Nach einiger Zeit wurde bemerkt, dass der Motor fühlbar sehr warm wurde. Nach einiger Recherche stellte sich heraus, dass der Motor auch ohne Bewegung Strom verwendet. Ein dementsprechender Sketch, als "if-Bedingungen", um den Motor von der Stromversorgung zu trennen, wurde versucht zu schreiben. In der Zeit der Stunde gelang dies allerdings nicht. Die Lösung dieses Problems soll nun von zu Hause angegangen werden. 
Eine weitere Problematik, die sich eröffnete, war die Ansteuerung des Servo Motors im Hinblick auf das weitere Profjekt. Um einen Gaskocher zu regulieren, erfordert es mehr als eine Umdrehung. Problematisch ist, dass der Schrittmotor nur die Information des "Weiter" oder "Zurück" kennt, jedoch nicht seine genaue Position. In irgendeiner Form wird daher eine mathematische Lösung erfordert, die den Nullpunkt des Schrittmotors als Startpunkt definiert, von welchem aus dann Befehle im oder gegen den Uhrzeigersinn gegeben werden. Wie dieses Problem konkret gelöst werden kann, ist bisher unklar. 
</p>
  
 <details>
     <summary>Screenshot von Fritzing</summary>
 <b>Screenshot von Fritzing</b>
  <img alt="Ansteuerung des Schrittmotors" src="https://user-images.githubusercontent.com/88385654/131680996-f6043d89-9102-4a8f-9ab9-bbe43314acf3.png">

</details>

  ## <p> <h2> <a id="Stundevom31.8.2021"> Stunde vom 31.8.2021 </a> <h2>
  Zu Beginn der Stunde, wurde das bestellte Thermometer angeschlossen. Die Gruppe entschied sich für ein auf Amazon erhätliches Thermometer, das für extrem hohe Temperaturen geeignet ist. Die Wahl fiel auf das "MAX6675". <a href="https://www.amazon.de/ANGEEK-MAX6675-thermocouple-Temperature-arduino/dp/B07X41RG6K/ref=sr_1_2_sspa?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&dchild=1&keywords=max6675&qid=1630502970&sr=8-2-spons&psc=1&spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUE3WkxHNEVaR0RIODUmZW5jcnlwdGVkSWQ9QTAzODIyOTMxVUI3TVFJTVk4VzNZJmVuY3J5cHRlZEFkSWQ9QTA2ODY3NDQxUTUxRVNaSlU2QTdSJndpZGdldE5hbWU9c3BfYXRmJmFjdGlvbj1jbGlja1JlZGlyZWN0JmRvTm90TG9nQ2xpY2s9dHJ1ZQ=="> Kauflink zum Produkt - Link von Amazon </a>
  
  Mit der Integration einer passenden Library für das Bauteil MAX6675, konnten im seriellen Monitor Temperaturwerte abgelesen werden. Damit die Funktion getestet werden konnte, gab es einen Extremtest mit einem Teelicht. Der Test war erfolgreich und die Werte stiegen, bzw. fielen je nachdem ob das Thermometer in die Flamme gehalten wurde oder nicht. 
 Anschließend arbeitete das Team an einem Code, der eine Temperaturbedingungen, mämlich ein Wert kleiner als 30 °C mit einer Bewegung des Schrittmotors koppelte. Ziel für die nächste Stunde war es diesen Code fertigzustellen. </p>
  
  ## <p> <h2> <a id="Stundevom1.9.2021"> Stunde vom 1.9.2021 </a> <h2>
Leider gelang die Fertigstellung nicht. Bei diesem recht anspruchsvollen Code, der einen wichtigen Teilschritt für das Projekt darstellt, ergaben sich viele kleinere Probleme. Teilweise waren dies Flüchtigkeitsfehler, wie die Auslassung eines Kommas, teilweise jedoch auch schwererwiegende Probleme, die innerhalb der Stunde nicht gelöst werden konnten. 
Außerdem wurde noch der Versuchsaufbau als Schaltplan der Ansteuerung des Schrittmotors digitalisiert und zu den Protokollen hinzugefügt.</p>

  ## <p> <h2> <a id="Stundevom7.9.2021"> Stunde vom 7.9.2021 </a> <h2>
  Auch diese Doppelstunde am Nachmittag stand ganz im Fokus des "Debugging". Gemeinsam mit Herrn Buhl wurde nach Fehlern gesucht. Relativ frustrierend war es zu sehen, dass sich an immer neuen Stellen Probleme ergaben mit denen die Gruppe am Anfang nicht gerechnet hat. 
  Um die Fehlerquellen besser identifizieren und zu beheben können, erfolgte ein Rückschritt. Die Codes wurden wieder voneinander getrennt und einzeln auf Fehler abgesucht. Am Ende der Stunde klappte immerhin das Ansteuerung des Schrittmotors, der aber aus noch unerfindlichen Gründen zu wenig Kraft besaß.</p>
  
  ## <p> <h2> <a id="Stundevom8.9.2021"> Stunde vom 8.9.2021 </a> <h2>
  In dieser Stunde konnten nun alle Fehlerquellen endgültig behoben werden, sodass der Code nun in seiner endgültigen From vorliegt. 
  Erklärung der auftretenden Probleme:
    - Das Problem, dass eine der vier Spulen des Schrittmotors nicht angesteuert wurde, sodass ein "Zucken" des Motors zwar sichtbar war, dieser sich aber nicht drehte, ergab sich durch einen Defintionsfehler in der Syntaxschreibweise der Library. Ein Komma, welches zwei Parameter trennte, wurde vergessen.
    - Des Weiteren trat das Phänomen eines schwachen Drehmoments auf. Der Motor arbeitete wie gewünscht, jedoch wurden Leerschritte gemacht, sobald Kraft auf den Motor wirkte. Beheben lies sich das Problem, indem die Einstellung der Schrittart von einem "Fullstep" auf einen "Halfstep" umgestellt wurde. Da nun in acht Zwischenschritten, statt in vier Zwischenritten pro Schritt gearbeitet wird, hat der Motor mehr Kraft und das Risiko für einen Leerschritt wird gesenkt. 
    - Die Erwärumung des Motors wurde durch eine Veränderung im Code verhindert: Dazu wurde im "main loop" eine Bedingung hinzugefügt, welche überprüft, ob der Stepper arbeitet. 
    - Das Projekt eines arduinogesteuerten Gaskochers erfodert das Festlegen einer Startposition. Das liegt daran, dass der Gaskocher nur einen begrenzten Drehradius hat. Außerdem kennt der Schrittmotor nicht die beiden Zustände des Kochers, mämlich ob Gas fließt oder nicht. Damit dieses Problem behoben werden kann, muss ein Startpunkt definiert werden. Bei dem von uns verwendeten "move"-Befehls speicherte der Schrittmotor jedoch weder seine Startposition noch seine aktuelle Position. Lediglich die Anzahl der Schritte wurde vorgegeben. Durch einen neuen "moveTo"-Befehl, wurde diese Problematik gelöst. Nun wird sowohl der Startpunkt als auch die aktuelle Position gespeichert und die Distanz zu dem angesteuerten Ziel berechnet.
    </p>

<details> 
    <summary>Arduion Code</summary>
    
```c 
#include <AccelStepper.h>
#include "max6675.h"

int soPin = 4;
int csPin = 5;
int sckPin = 6;

float Temp;
int durchlaeufe;

int KnopfPin = 2;
bool Knopfzustand;
 
#define HALFSTEP 8
 
#define motorPin1 9
#define motorPin2 10
#define motorPin3 11
#define motorPin4 12

AccelStepper stepper1(HALFSTEP, motorPin1, motorPin3, motorPin2, motorPin4);

MAX6675 thermo(sckPin, csPin, soPin);
 
void setup()
{
  pinMode(KnopfPin, INPUT);
  Knopfzustand = digitalRead(KnopfPin);
  
  Serial.begin(9600);
  Serial.println("Start der Auslese");
  delay(1000);
  
  stepper1.setCurrentPosition(0);
  stepper1.setMaxSpeed(1000.0);
  stepper1.setAcceleration(1000.0);
  stepper1.setSpeed(1000);
} 
 
void loop()
{
  Knopfzustand = digitalRead(KnopfPin);
  Serial.println(Knopfzustand);
  
  float Temp = thermo.readCelsius();
  Serial.print("Temperatur in C =");
  Serial.println(Temp);

delay(300);

   if(Knopfzustand == 1) {
    stepper1.move(500);
    stepper1.runToPosition();
    stepper1.disableOutputs();
   }
         
 if(thermo.readCelsius() >= 50){
  stepper1.moveTo(0);
  stepper1.runToPosition();
  stepper1.disableOutputs();
  }
}
    
```
</details>

  ## <p> <h2> <a id="Stundevom14.9.2021"> Stunde vom 14.9.2021 </a> <h2>
  Diese Informatikstunde musste leider ausfallen. Nachdem der Code in der letzten Stunde fertiggestellt wurde, hat sich die Gruppe dazu entschieden an anderer Stelle das Projekt nach vorne zu bringen. Es wurde sich darauf verständigt die Woche über ein Brainstorming zur Hardware des Gaskochers zu starten. Dieses Brainstorming sollte getrennt passieren, damit mögichst viele unterschiedlichen Ideen und Ansätze bei der Besprechung in der nächsten Woche vorgetragen werden. 
    </p>
    
  ## <p> <h2> <a id="Stundevom15.9.2021"> Stunde vom 15.9.2021 </a> <h2>
  Diese Informatikstunde musste leider ausfallen. Das Brainstorming zur Hardware wurde, wie in der letzten Stunde festgelegt, von den Gruppenmitgliedern zu Hause durchgeführt. 
    </p>
    
## <p> <h2> <a id="Stundevom21.9.2021"> Stunde vom 21.9.2021 </a> <h2>
 In dieser Stunde wurden die unterschiedlichen Ideen gesammelt und zusammengetragen. Gemeinsam wurden Ideen verworfen, weitergeführt und konkretisiert. Zur besseren Übersicht und Dokumentation der Gedankenprozesse, wurde eine MindMap erstellt. 
    </p>
    
<details>
     <summary>MindMap zum arduinogesteuerten Gaskocher</summary>
    
<img alt="MindMap zum arduinogesteurten Gaskocher" src="https://user-images.githubusercontent.com/88385654/134305833-4a90c295-e816-4e00-a15e-3394e86445d0.png">

</details>
 
    
## <p> <h2> <a id="Stundevom22.9.2021"> Stunde vom 22.9.2021 </a> <h2>
    
In dieser Unterichtseinheit widmete sich die Gruppe einem erneurten Konzept zu der Dokumentation auf Git hub. Die Gruppe entschied sich für das Layout die Codes und auch die Bilder als aufklappbare Module zu gestalten. Außerdem werden, durch die Angabe der Programmiersprache "c", die Arduino Codes automatisch eingefärbt. Zusätzlich wurde auch ein Gaskocher als Herzstück für die praktische Umsetzung bestellt.
<a href="https://www.amazon.de/gp/product/B085ZJJ2Q5/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&psc=1"> Kauflink zum Produkt - Link von Amazon </a>
Für die Hausaufgabe entschied sich die Gruppe nach einem alten Kochtopf, der bereits im Besitz ist, zu suchen. 
    
</p>
    
## <p> <h2> <a id="Stundevom28.9.2021"> Stunde vom 28.9.2021 </a> <h2>
 
Das Thema der Informatikstunde war die Ansteuerung eines Rotary Encoders, um in Hinblick auf das Gesamtprojekt über einen Eingaberegler eine einstellbare Gradzahl zu erhalten. 
    </p>
    
<details>
    <summary>Arduino Code</summary>
    
```c
    
#include <AccelStepper.h>
#include "max6675.h"

const int PinA = 2;
const int PinB = 3;
const int PinSW = 8;

const int soPin = 4;
const int csPin = 5;
const int sckPin = 6;

float Temp;

int lastCount = 0; 
volatile int virtualPosition = 0; 

 
#define HALFSTEP 8
#define motorPin1 9
#define motorPin2 10
#define motorPin3 11
#define motorPin4 12

AccelStepper stepper1(HALFSTEP, motorPin1, motorPin3, motorPin2, motorPin4);

MAX6675 thermo(sckPin, csPin, soPin);
 
void setup()
{
  Serial.begin(9600);
  delay(1000);
  
  stepper1.setCurrentPosition(0);
  stepper1.setMaxSpeed(1000.0);
  stepper1.setAcceleration(1000.0);
  stepper1.setSpeed(1000);

  pinMode(PinA, INPUT);
  pinMode(PinB, INPUT);
  pinMode(PinSW, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(PinA), isr, LOW);

  Serial.println("Start");
} 
 
void loop()
{
  float Temp = thermo.readCelsius();

delay(300);      
 if(thermo.readCelsius() >= 50){
  stepper1.moveTo(0);
  stepper1.runToPosition();
  stepper1.disableOutputs();
  }
 
  if ((!digitalRead(PinSW))) {
    stepper1.moveTo(virtualPosition);
    Serial.print("Run to: ");
    Serial.println(virtualPosition);
    stepper1.runToPosition();
    stepper1.disableOutputs();
    while (!digitalRead(PinSW))
      delay(10);
    Serial.println("Run completet");
  }

  
  if (virtualPosition != lastCount) {
    
    Serial.print(virtualPosition > lastCount ? "Up  :" : "Down:");
    Serial.println(virtualPosition);

    lastCount = virtualPosition ;
  }
}

void isr ()  {
  static unsigned long lastInterruptTime = 0;
  unsigned long interruptTime = millis();

  if (interruptTime - lastInterruptTime > 5) {
    if (digitalRead(PinB) == LOW)
    {
      virtualPosition-=2 ;
    }
    else {
      virtualPosition+=2 ;
    }

  }
  
  lastInterruptTime = interruptTime;
} 
    
``` 
</details>
    
Des Weiteren wurde der bestellte Gaskocher begutachtet und auf seine Funktion geprüft. 
    
<details>
    <summary>Bilder des Gaskochers</summary>
<b>Bilder des Gaskochers</b>   
<img alt="Gaskocher" src="https://user-images.githubusercontent.com/88385654/135102210-1ae633c2-4d40-4c06-969e-4b87265e4c0a.jpeg">
    
<img alt="Nahaufnahme vom Gaskocher" src="https://user-images.githubusercontent.com/88385654/135102281-da073c62-8bce-4344-8e4c-2852d3b0658a.jpeg">
    
<img alt="zündender Gaskocher" src="https://user-images.githubusercontent.com/88385654/135102245-8d134890-a42c-4488-806d-178076c5ecbc.jpeg">
    
<img alt="Anschlussstelle für die Gasflasche" src="https://user-images.githubusercontent.com/88385654/135102335-6fd78250-aa52-4efd-b277-b89b34263296.jpeg">
    
</details>

## <p> <h2> <a id="Stundevom29.9.2021"> Stunde vom 29.9.2021 </a> <h2>
    
Aufgrund einer Vorabiturklausur musste diese Informatikstunde leider ausfallen. Für die Ferien nahm sich die Gruppe vor an dem Projekt weiter zu arbeiten, damit das Projekt nach den Ferien in die finale Phase gebracht werden kann. </p>
    
## <p> <h2> <a id="Stundevom19.10.2021"> Stunde vom 19.10.2021 </a> <h2>
    
In dieser Stunde wurde der Abgabetermin des Projektes auf den 6.12.2021 festgelegt. Aufgrund dieser Festlegung nahm sich die Gruppe Zeit einmal den bisherigen Verlauf der Arbeit zu reflektieren, den momentanen Stand zu analysieren und kommende Schritte zu planen. </p>
    
<details>
    <summary> bisheriger Stand des Projekts </summary>
<b>Software</b>

<ul>
    <li>Ein "rotary Encoder" kann eingestellt werden und mit Hilfe einer "interrupt-Funktion", können diese eingestellten Werte ausgegeben werden. Dieser soll beim fertigen Projekt die Funktion einer einstellbaren Temperatur übernehmen.</li>
    <li>Dieser eingestellte Wert, kann als Schrittanzahl an einen Schrittmotor weitergeleitet werden. Dieser Motor läuft die Anzahl der eingestellten Schritte ab und soll beim fertigen Produkt den Gasfluss regulieren.</li>
    <li>Die Werte eines Thermoters könenn gelesen werden.</li>
</ul>
    
<b>Hardware</b>
    
<ul>
      <li>Ein für das Projekt passendes, für besonders hohe Temperaturen geeignetes Thermoter, wurde angeschafft.</li>
      <li>Für die Hardware wurde bereits einen Gasbrenner mit passender Gasflasche organisiert. </li>  
</ul>

</details>
    
<details>
    <summary> noch zu erledigende Arbeitsschritte </summary>

<b>Software</b>
    
<ul>
    <li>Eine Umrechnung von dem eingestellten Wert beim "rotary Encoder" in eine Temperatur in ° C und eine Umrechnung von dieser Temperatur in eine prozentuale Öffnung der Gasflasche bzw. eine Anzahl von Schritten, die der Schrittmotor gehen soll, tritt ein. Um dieses Prinzip zu vereinfachen wird eine Differenz zwischen der eingestellten und gemessenen Temperatur gebildet. Anhand dieser Differenz wird anschließend berechnet wie stark die Gasflasche geöffnet werden soll.</li>
    <li>Programmierung eines einfachen LCD Displays, um die Gradanzahl anzeigen zu lassen.</li> 
</ul>
    
<b>Hardware</b>
    
<ul>
    <li>Es muss ein 3-D gedrucktes Verbindungsstück von Schrittmotor zu Gasregler des Brenners designt werden</li>
    <li>Es muss eine geeignete Vorrichtung, auf der der Arduino platziert werden kann, gebaut werden.</li>
    <li>Es muss ein Topf, in den das Thermometer eingearbeitet werden.</li> 
</ul>

</details>
    
Nachdem diese Übersicht erstellt worden war, arbeitete die Gruppe an dem Problem der Umrechnung von eingestelltem Wert in eine Steuerung des Gasflusses. Letzendlich entschied sich die Gruppe für eine logistische Kurve, da bei dieser Funktion, bei einer großen Differenz eine starke Öffnung, und bei niedriger Differenz nur eine kleine Öffnung, erreicht wird. Jeder errechneten Differenz wird ein passender y-Wert als Anzahl von Schritten zugeordnet. <br> Funktion: f(x)= 100/(1+1,1^(-x+50))+1 <br>
Ob sich diese Funktion als passend erweist muss im Laufe des Projektes nach Testung mit Prototypen experimentell herausgefunden werden. <br>
Außerdem wurde an der Software weitergearbeitet.
<details>
	<summary>Bild der Funktion von GeoGebra</summary>
<img alt="Bild der Funktion" src="https://user-images.githubusercontent.com/88385654/144412226-ba5ff562-d237-46a6-bdcb-3dc8847182ea.jpg">

</details>
    
 ## <p> <h2> <a id="Stundevom20.10.2021"> Stunde vom 20.10.2021 </a> <h2>
    
In dieser Stunde wurde arbeitsteilig vorgegangen. Während weiter an der Software programmiert wurde, beschäftigte sich ein Teil der Gruppe auch mit der technischen Umsetzung des Verbindungsstückes von Schrittmotor zu Gasflasche. Dafür wurde die Software "TinkerCAD" installiert. Link zu "TinkerCAD": https://www.tinkercad.com/
Die Einarbeitung in dieses Programm begann, damit in naher Zukunft erste 3-D Modelle und Probedrucke entstehen können, um Software und Hardware, miteinander fusioniert, testen zu können. 
Von Zuhause wurden erste 3-D Modelle erstellt und mit Hilfe der Software Cura, wurde dieses Modell als G-Code exportiert und gedruckt.</p>
    
<details>
    <summary>Bildergalerie</summary>
    
<b>Arbeitsoberfläche von Tinker CAD</b>
<img alt="Arbeitsoberfläche TinkerCAD" src="https://user-images.githubusercontent.com/88385654/138922421-797a0145-09c3-492d-af3f-21c22fe34ce3.PNG">

<b>Screenshots Testkörper #1</b>
<img alt="Testkörper #1 von der Seite" src="https://user-images.githubusercontent.com/88385654/138923203-582cccf3-d97d-4451-831d-c54c6ea51669.PNG">
<img alt="Testkörper #1 von unten" src="https://user-images.githubusercontent.com/88385654/138923158-e0b791a6-fb78-4774-b799-8f18413eadbc.PNG">
<img alt="Testkörper #1 von oben" src="https://user-images.githubusercontent.com/88385654/138923511-57f758e9-c357-47dc-94b6-71f9cbee383c.PNG">

</details>

## <p> <h2> <a id="Stundevom26.10.2021"> Stunde vom 26.10.2021 </a> <h2>
  
Ziel dieser Doppelstunde war die Analyse des bisherigen 3-D Modells. Einige Maße, zum Beispiel der Durchmesser des Loches für den Gasregler, fielen zu klein aus. Des Weiteren fiel auf, dass die mit dem Schrittmotor verbundene Platte eine freie Drehung verhindert und daher als gesondertes Teil designt werden muss. Nach erneuter Vermessung mit einer Schieblehre wurden zwei verschiedene Designs erstellt. Diese sollten zu Hause gedruckt werden und Grundlage für die Arbeit in der nächsten Stunde sein. Außerdem war die Befestigung von Schrittmotor, Arduino und Gasflasche ein Thema, da der Schrittmotor so befestigt sein muss, dass dieser sich nicht mitdreht. Durch die glatte und abgerundete Oberfläche der Gasflasche und der Zuleitung des Gaskochers gestaltete sich diese Frage als schwierig. Über die zusätzliche Erstellung von weiteren 3-D Drucken wurde gesprochen. 
    
<details>
    <summary>Screenshots der 3-D Modelle</summary>
    
<b>Testkörper #2a</b>
<img alt="Testkörper #2a von der Seite" src="https://user-images.githubusercontent.com/88385654/138924908-7050cb53-8365-42f8-9390-4ead4f05cb67.PNG">
<img alt="Testkörper #2a von unten" src="https://user-images.githubusercontent.com/88385654/138924970-f345f043-6bc3-4c6c-a1a5-a9c1dca53208.PNG">
<img alt="Testkörper #2a durchichtig" src="https://user-images.githubusercontent.com/88385654/138925059-03278e96-ff99-4742-84f5-2e5742e0dd57.PNG">

<b>Testkörper #2b</b>
<img alt="Testkörper #2b von der Seite" src="https://user-images.githubusercontent.com/88385654/138925638-66a30600-2254-4d1a-ba06-c520c1020753.png">
<img alt="Testkörper #2b von unten" src="https://user-images.githubusercontent.com/88385654/138925685-33fc2834-a1cf-4624-8eed-b5633e9a9a4b.png">
<img alt="Testkörper #2b durchsichtig" src="https://user-images.githubusercontent.com/88385654/138925747-90a1d41d-6b1c-4655-a728-e38205859cad.png">
<img alt="Testkörper #2b durchsichtig" src="https://user-images.githubusercontent.com/88385654/138925765-0f321573-1e3b-460e-b747-c63c4d1051b9.png">

</details>

## <p> <h2> <a id="Stundevom27.10.2021"> Stunde vom 27.10.2021 </a> <h2>
    
Die Software wurde in dieser Stunde weiter nach vorne gebracht. Ein Zwischenstand wurde erreicht, sodass eine eingestellte Temperatur mit einer gemessenen Temperatur ins Verhältnis gesetzt wird und sich aufgrund dieser Differenz eine prozentuale Öffnung der Gasflasche ergibt. Damit wurde ein wichtiger Meilenstein erreicht. Video zum bisherigen Versuchsstand: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Für die Zukunft steht noch die Programmierung eines LCD-Displays an. Zusammen mit den 3-D Modullen ist das Projekt nun aber bereits so weit, dass das Projekt als ganzes getestet werden kann. 
    
<details>
    <summary>bisheriger Code</summary>
    
```c
    
#include <AccelStepper.h>
#include "max6675.h"

const int PinA = 2;
const int PinB = 3; 
const int PinSW = 8;

const int soPin = 4;
const int csPin = 5;
const int sckPin = 6;

float tatTemp;

int lastCount = 0; 
volatile int eingestellteTemp = 0; 
float pVentil = 0;
int stepperPosition = 0;
float tempDifferenz;
const float schritteproprozent = 71.68;

int rotarySchrittwert = 5;


 
#define HALFSTEP 8
#define motorPin1 9
#define motorPin2 10
#define motorPin3 11
#define motorPin4 12

AccelStepper stepper1(HALFSTEP, motorPin1, motorPin3, motorPin2, motorPin4);

MAX6675 thermo(sckPin, csPin, soPin);
 
void setup()
{
  
  Serial.begin(9600);
  delay(1000);
  
  stepper1.setCurrentPosition(0);
  stepper1.setMaxSpeed(1000.0);
  stepper1.setAcceleration(1000.0);
  stepper1.setSpeed(1000);

  pinMode(PinA, INPUT);
  pinMode(PinB, INPUT);

  pinMode(PinSW, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(PinA), isr, LOW);

  Serial.println("Start");

} 
 
void loop()
{
  
  float tatTemp = thermo.readCelsius();
         delay(300);
      
  Serial.print("Eingestellte Temperatur: ");
  Serial.println(eingestellteTemp);
         Serial.println(" ");
         
  Serial.print("Gemessene Temperatur in C: ");
  Serial.println(tatTemp);
         Serial.println(" ");
         
  Serial.print("Temperaturdifferenz:");
  Serial.println(tempDifferenz);
         Serial.println(" ");
         
  Serial.print("Ventilöffnung in Prozent: ");
  Serial.println(pVentil);
         Serial.println(" ");

  Serial.println("------------------------------------");


delay(100);
  
  // Is someone pressing the rotary switch?
  if ((!digitalRead(PinSW))) {
    rotarySchrittwert = 1;
  }
  else{
    rotarySchrittwert = 5;
  }

  tempDifferenz = eingestellteTemp - tatTemp;

  stepperPosition = pVentil * schritteproprozent;

  pVentil= 100/(1+ pow(1.1, -tempDifferenz + 50)) + 1;
  pVentil = min(100, max(0, pVentil));
  
  stepperPosition = min(7168, max(0, stepperPosition));
  
stepper1.moveTo(stepperPosition);
stepper1.runToPosition();
stepper1.disableOutputs();
  
}


void isr ()  {
  static unsigned long lastInterruptTime = 0;
  unsigned long interruptTime = millis();

  if (interruptTime - lastInterruptTime > 5) {
    if (digitalRead(PinB) == LOW)
    {
      eingestellteTemp-= rotarySchrittwert ;
    }
    else {
      eingestellteTemp+= rotarySchrittwert ;
    }

    eingestellteTemp = min(300, max(0, eingestellteTemp));

  }
  lastInterruptTime = interruptTime;
} 
    
```
    
</details>
    
## <p> <h2> <a id="Stundevom2.11.2021"> Stunde vom 2.11.2021 </a> <h2>
    
Zu Beginn der Stunde wurde der in der letzten Stunde erreichte Erfolg Herrn Buhl präsentiert. Anschließend wurde das Ziel ein LCD-Display, dass die eingestellten Temperaturen anzeigt, in Angriff genommen. Die Einarbeitung in die Programmierung eines LCD-Displays begann. 
    
## <p> <h2> <a id="Stundevom3.11.2021"> Stunde vom 3.11.2021 </a> <h2>
    
Während dieser Unterrichtseinheit wurde weiter an dem LCD-Display gefeilt. 
Außerdem wurde an dem 3-D Modell gearbeitet und ein überarbeiteter Prototyp erstellt. 

<details>
    <summary>Screenshot des 3-D Modells</Summary>

## Screenshot von der Seite <img alt="Screenshot von der Seite" src="https://user-images.githubusercontent.com/88385654/140654383-49f75fb1-e714-4139-b03c-9751df766acc.PNG">
## Screenshot von unten <img alt="Screenshot von unten" src="https://user-images.githubusercontent.com/88385654/140654396-31ae6d5f-827a-439e-92cd-132f961bc5e8.PNG">
## Screenshot von oben <img alt="Screenshot von oben" src="https://user-images.githubusercontent.com/88385654/140654494-065e4e97-969f-40f6-8f63-5014777acbf1.PNG">
## transparenter Screenshot <img alt="transparenter Screenshot" src="https://user-images.githubusercontent.com/88385654/140654565-fc945d5c-20f8-4a58-8cc6-33af6fe14cd2.PNG">

</details>

## <p> <h2> <a id="Stunde von 9.11.2021"> Stunde vom 9.11.2021 </a> <h2>
                                        
Aufgrund der Vorabiturklausuren, musste diese Stunde leider ausfallen. Von zu Hause wurde allerdings das in der letzten Stunde designte Modell gedruckt, um es in der Praxis testen zu können. 
                                        
## <p> <h2> <a id="Stundevom10.11.2021"> Stunde vom 10.11.2021 </a> <h2>

Aufgabe dieser Stunde war es den programmierten Code zu kommentieren, damit er für alle auch an dem Projekt nicht beteiligten Personen leicht verständlich ist. 
<details>
    <summary>kommentierter Code</summary>
 
 ```c
  /*
*/
// in diesem Abschnitt werden die benötigten Bibliotheken eingebunden:
#include <LiquidCrystal_I2C.h>                         //ermöglicht eine einfache Komunikation mit dem LC-Display mit nur 2 Datenpins; Quelle: https://github.com/fdebrabander/Arduino-LiquidCrystal-I2C-library                                                                                                                      
#include <Wire.h>                                      //wird für die I2C-LCD Bibliothek zusätzliche für die Kommunikation benötigt benötigt; Quelle: Vorinstalierte Arduino-Bibliothek
#include <AccelStepper.h>                              //ermöglicht einfache Programmierung des Schrittmotors; Quelle: Arduino-Biliotheken-Verzeichnis
#include "max6675.h"                                   //ist für die Auslese des Thermosensors zuständig; Quelle: Arduino-Biliotheken-Verzeichnis von Adafruit

//in diesem Abschnitt werden alle benötigten Variablen und Konstanten definiert:
  //zunächst werden die Pin-Belegung:
const int PinA = 2;   //CLK: Clock-Pin für den Rotary-Encoder
const int PinB = 3;   //DT:  Daten-Output-Pin des Rotary-Encoder
const int PinSW = 8;  //SW:  Knopf-Pin des Rotary-Encoder

const int soPin = 4;  //SO: Serieller Outputput-Pin für das Thermoelement
const int csPin = 5;  //CS: Chip-Select-Pin für das Thermoelement
const int sckPin = 6; //SCK: Serieller Cklock-Pin für das Thermoelement

#define motorPin1 9   //Die 4 benötigten Pins für den Schrittmotor werden festgelegt 
#define motorPin2 10
#define motorPin3 11
#define motorPin4 12

  //außerdem werden verschiedene Variablen für die Programmierung benötigt:
float tatTemp;                                //Variable für die gemessene Temperatur in Grad (float: mit 2 Nachkommastellen)
int lastCount = 0;                            //speichert den letzten Wert des Rotaryencoders
volatile int eingestellteTemp = 0;            //eingestellte Temperatur: wird durch die ISR (Interrupt Service Routine) aktualisiert
float pVentil = 0;                            //Ventilstellung in Prozent (100% entspricht vollständiger Öffnung)
int stepperPosition = 0;                      //Position des Schrittmotors in Schritten (4096 Schritte = 360°)
float tempDifferenz;                          //Differenz zwischen eingestellter Temperatur und gemessener Temperatrur  
const float schritteproprozent = 71.68;       //71.68 Schritte des Schrittmotors entpricht 1° Ventilöffnung 
int rotarySchrittwert = 5;                    //Werigkeit jedes am Rotaryencoder eingestellten Schrittes

#define HALFSTEP 8                            //der Schrittmotor soll im Halfstep-Modus betrieben

AccelStepper stepper1(HALFSTEP, motorPin1, motorPin3, motorPin2, motorPin4);    //das Objekt "stepper1" wird Initialisiert
LiquidCrystal_I2C lcd(0x3F, 16, 2);                                             //das Objekt "lcd" wird Initialisiert
MAX6675 thermo(sckPin, csPin, soPin);                                           //das Objekt "thermo" wird Initialisiert


//Der folgende Programmteil wird nur ein mal abgerufen:
void setup()       
{
  Serial.begin(9600);    //die serielle Kommunikation wird gestartet
    delay(1000);         //Zeit, damit sich die Sensoren kalibrieren können 
  lcd.begin();           //das LC-Display wird gestartet  
  lcd.backlight();       //die Hintergrundbeleuchtung des LCDs wird aktiviert 
  
  stepper1.setCurrentPosition(0);     //die aktuelle Position des Schrittmotors wird = 0 gesetzt
  stepper1.setMaxSpeed(1000.0);       //die maximale Geschwindigkeit des Steppers wird 1000 Schritte pro Sekunde gesetzt 
  stepper1.setAcceleration(1000.0);   //die Beschleunigung des Steppers wird 1000 Schritte pro Sekunde^2 gesetzt 
  stepper1.setSpeed(1000);            //die Geschwindigkeit des Steppers wird auf 1000 Schritte pro Sekunde festgelegt 

  pinMode(PinA, INPUT);               //PinA und PinB sind INPUTs, um die Signale des Rotary-Encoders zu lesen
  pinMode(PinB, INPUT);
  pinMode(PinSW, INPUT_PULLUP);       //der SW-Pin ist Potentailfrei; es wird ein Wiederstand benötigt, dafür wird der im Arduino verbaute Pullup-Wiederstand verwendet

  attachInterrupt(digitalPinToInterrupt(PinA), isr, LOW);  //die Interupt-Routine "ISR" wird dann ausgelöst, wenn der PinA = LOW ist
  
  Serial.println("Start");  //das Setup ist ausgeführt; im seriellen Monitor wir das mit "Start" signalisiert
} 

//Der folgende Programmteil wird bei Vollendung Wiederholt
void loop()
{
  float tatTemp = thermo.readCelsius();               //das Thermomenter wird ausgelesen und der Wert als Variable überführt
         delay(300);
      
  Serial.print("Eingestellte Temperatur: ");          //der serielle Monitor dient unserem Projekt als Kontrollbildschirm, deshalb werden alle wichtigen Werte abgebildet: 
  Serial.println(eingestellteTemp);
         Serial.println(" ");
         
  Serial.print("Gemessene Temperatur in C: ");
  Serial.println(tatTemp);
         Serial.println(" ");
         
  Serial.print("Temperaturdifferenz:");
  Serial.println(tempDifferenz);
         Serial.println(" ");
         
  Serial.print("Ventilöffnung in Prozent: ");
  Serial.println(pVentil);
         Serial.println(" ");

  Serial.println("------------------------------------");  //dient zur Übersicht im seriellen Monitor

  lcd.clear();                         //leert das LCD, damit neue und alte Werte sich nicht überlagern
  lcd.setCursor(0, 0);                 //das LCD soll die gemessene Temperatur und die eingstellte Temperatur darstellen: 
  lcd.print("ein.Temp: ");
    lcd.print(eingestellteTemp);
    lcd.setCursor(15, 0);
    lcd.print("C");
  lcd.setCursor(0, 1);
  lcd.print("akt.Temp: ");
    lcd.print(tatTemp);
    lcd.setCursor(15, 1);
    lcd.print("C");
  
delay(100);                           //0,1 Sekunden Pause, damit die Sensoren neue Werte bilden können
  
  if ((!digitalRead(PinSW))) {        //wenn der Knopf des Encoders gedrückt wird (Strom am PinSW anliegt), ist der Schrittwert = 1
    rotarySchrittwert = 1;
  }
  else{                               //anderenfalls beträgt der Schrittwert = 5
    rotarySchrittwert = 5;
  }
  
   
  //wenn der folgende Programmteil aktiviert wird, kann bestimmt werden, ob der Wert des Encoders momentan veringert oder vergrößert wird
 /* if (eingestellteTemp != lastCount) {
      Serial.println("Eingestellte Temperatur: ");
      Serial.print(eingestellteTemp > lastCount ? "Up  :" : "Down:");
      Serial.println(eingestellteTemp);
      
      lastCount = eingestellteTemp ;
  }
 */

  tempDifferenz = eingestellteTemp - tatTemp;               //Differenz aus eingestellter Temperatur und gemessener Temperatur wird gebildet und als int Variable gespeichert

  stepperPosition = pVentil * schritteproprozent;           //die Position des Steppers ist das Produkt von der gewünschten Ventilstellung und der Anzahl der Schritte, welche für 1% benötigt werden

  //pVentil = (10 * sqrt(tempDifferenz) - 5);
  pVentil= 100/(1+ pow(1.1, -tempDifferenz + 50)) + 1;      //mathematische Funktion, welche die Temperaturdifferenz in eine Ventilstellung umsetzt
                                                            //zwar handelt es sich um einen logistsichen Zusammenhang, jedoch gilt grundsätzlich: Je größer die Temperaturdifferenz, desto weiter ist das Ventil geöffnet
  pVentil = min(100, max(0, pVentil));                      //der Wertebereich der Ventilöffnung wir zwischen 0% und 100% begrenzt
  
  //Serial.print("Ventiloffnung in P:");
  //Serial.println(pVentil);
   
  stepperPosition = min(7168, max(0, stepperPosition));     //um sicherzugehen, dass der Motor nicht zu weit dreht und die Hardware beschädigt, wird auch die maximale Drehung begrenzt
  
//dieser Programmabschnitt aktuallisert die Position des Schrittmotors:
stepper1.moveTo(stepperPosition);                     
stepper1.runToPosition();          //leider wird der Code an diese Stelle pausiert; der Schrittmotor sollte also möglichst schnell drehen
stepper1.disableOutputs();
  
}

//der folgende Programmteil ist die Interrupt-Service-Routine
void isr ()  {
  static unsigned long lastInterruptTime = 0;
  unsigned long interruptTime = millis();

  //wenn der Interupt schneller als 5 ms nach dem vorherigen Interrupt kommt, wird dieser Ignoriert. Dadurch wird "Bounce" verhindert.
  //Bounces sind Signale, welche beim Herstellen eines mechanischen Kontaktes entstehen. Der Kontakt "flimmert". Wenn das nicht berücksichtigft wird, entstehen mehrere kurze Signale, auch wenn nur ein Schritt gedreht wurde
  if (interruptTime - lastInterruptTime > 5) {
    if (digitalRead(PinB) == LOW)
    {
      eingestellteTemp-= rotarySchrittwert ; 
    }
    else {
      eingestellteTemp+= rotarySchrittwert ; 
    }

    eingestellteTemp = min(300, max(0, eingestellteTemp));    //die Temperatur, welche eingestellt werden kann, ist zwischen 0° und 300° begrenzt 


  }
  lastInterruptTime = interruptTime;                          //es wird gespeichert, wann der letzte Interupt war
}   
     
```
</details>
                                       
<details>
   <summary>Bilder vom 3-D Modell</summary>
    
<img alt="Bild von der Seite" src="https://user-images.githubusercontent.com/88385654/142202234-e1abc1bf-2814-4591-be4a-94b3180315f9.jpeg">
<img alt="Bild von oben" src="https://user-images.githubusercontent.com/88385654/142202274-e2d83ce0-3351-4fba-946a-7fae29b117e4.jpeg">
<img alt="Bild von schrägoben" src="https://user-images.githubusercontent.com/88385654/142202478-73d68ed8-1be3-4f2a-a748-9a75e9050e82.jpeg">
    
</details>
    
## <p> <h2> <a id="Stundevom16.11.2021"> Stunde vom 16.11.2021 </a> <h2>

In dieser Stunde wurde eine passende library für das LCD-Display installiert. Link zur Quelle: https://github.com/fdebrabander/Arduino-LiquidCrystal-I2C-library
Außerdem wurden mit dem gedruckten 3-D Modell erste Tests unter Aufsicht von Herrn Buhl durchgeführt. Nachdem der Schrittmotor teilweise nicht genug Kraft hatte, um das Ventil des Gaskochers zu öffnen, wurde die Betriebsspannung des Motors 8 Volt erhöht.
Ein Video von den ersten Tests wurde von zu Hause aus aufgenommen. Link zum Video: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
## <p> <h2> <a id="Stundevom17.11.2021"> Stunde vom 17.11.2021 </a> <h2>

Ziel dieser Informatikstunde war es den <font red> Steckplan des Projekts mit Hilfe der Software "Fritzing" zu digitalisieren.</font red> Außerdem wurde ein Kochtopf aus dem Kellerbestand einer befreundeten Familie organisiert. Die Planung für das finale Projekt wurde weitergebracht.
Das finale Projekt soll in einer Box transportiert werden können und möglichst wenig Platz einnehmen. Dafür sollen alle Verbindung sicher gesteckt bzw. gelötet werden und in einem Kasten aus Holz oder Metall versteckt und geschützt werden. Des Weiteren soll der Rotary Encoder mit einem Knopf ausgestattet werden, damit die Bedienung erleichtert ist. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
<details>
    <summary>Screenshot von fritzing</summary>

</details>
    
<details>
    <summary>Bilder vom Kochtopf</summary>
    
<img alt="Bild vom Topf" src="https://user-images.githubusercontent.com/88385654/143242171-68d6ce8a-6b76-45a5-a037-10bac7595723.jpeg">
    
<img alt="Bild von oben" src="https://user-images.githubusercontent.com/88385654/143242185-4f1a83c9-f2b1-43d9-b9f9-25b503340d48.jpeg">

<img alt="Bild von der Seite" title="Bild von oben" src="https://user-images.githubusercontent.com/88385654/143242106-e8517588-22b7-4c0c-a48b-3ecdfe90af6f.jpeg">

</details>
    
## <p> <h2> <a id="Stundevom23.11.2021"> Stunde vom 23.11.2021 </a> <h2>

In dieser Stunde wurde angefangen die Projektseite zu designen. Über Layout und eine ansprechende Gestaltung wurde gesprochen. In der Diskussion war eine Slideshow, die allerdings nur in Kombination von html und css oder html and javascript zu realisieren wäre. Eine simplere Gestaltung, die bentutz wurde, war die Implementierung einer GIF-Datei. 

## <p> <h2> <a id="Stundevom24.11.2021"> Stunde vom 24.11.2021 </a> <h2>
  
In dieser Stunde wurde zusammen mit Herrn Buhl der Kochtopf inspiziert und über eine Verbindung von Temperaturmesser in den Topf diskutiert. Problematisch ist, dass der Temperaturmesser nicht überall wasserdicht ist, aber auch nicht seitlich in den Topf, sondern in den Deckel integriert werden. Dies hat den Vorteil, dass der Topf frei beweglich ist und leicht von der Flamme genommen werden kann. Von zu Hause soll probiert werden den Temperaturfühler so abzudichten, dass er zwar die Temperatur ohne große Zeitverzögerung messen kann, aber wasserdicht ist, um ins Wasser gehalten werden zu können. 
    
## <p> <h2> <a id="Stundevom30.11.2021"> Stunde vom 30.11.2021 </a> <h2>
     
Die Abdichtung des Thermometers von zu Hause klappte gut. In der Werkstatt wurden alte Dichtungen aus Restbeständen benutzt, um alle kritischen Verbindungen abzudichten. Mit Hilfe einer alten Kupferröhre konnte das Kabel vor äußeren Einflüssen geschützt werden. Der Kanal, durch den das Thermomether verläuft, wurde nun am Thermometerkopf und an der Öffnung Röhre-Topf mit Dichtungen versehen.  
Außerdem wurden im Baumarkt fehlende Teile besorgt, wie zum Beispiel ein Blech und Winkel, damit der Schrittmotor an das Ventil der Gasflasche montiert werden kann. Die Gruppe entschied sich gegen eine Verankerung des Motors mit dem Boden. Die Umsetzung wäre hier, zum Beispiel durch ein Dreibein, deutlich erleichtert gewesen, aufgrund von optischen Gründen, entschied sich die Gruppe jedoch einstimmig dagegen. 
Die letzte Vorraussetzung für die reibunglose Umsetzung war eine Bohrung in den Edelstahldeckel des Topfes, durch das das Thermometer mit dem Topfinhalt in Kontakt kommt. Der Vorteil davon ist, dass nicht der Topf selber, sondern nur der Deckel fest mit dem Kocher verankert ist und man somit mehr Freiheit und ebenfalls Sicherheit erreichen kann. Die Bohrung erfolgte in der Werkstatt eines Freundes. Wichtig für die Bohrung von Edelstahl ist die Verwendung eines Standborhers, eine Körnung des Werkstoffes, der richtige Aufsatz, eine niedrige Drehzahl und beölen der Bohrfläche, damit weniger Hitze entsteht. 
Nachdem alle von zu Hause erreichten Dinge dokumentiert und aufgeschrieben waren, fokussierte die Gruppe sich auf die Projektseite und Optimierung der Stundenprotokolle. Außerdem wurde die vorletzte Stunde auch dazu genutzt sich final mit Herrn Buhl auszutauschen und über mögliche Verbesserungen zu sprechen. 
Als Vorbereitung zur nächsten Stunde soll erneut an der Hardware gearbeitet werden, damit die ersten Probeversuche und Videos am Mittwoch Nachmittag durchgeführt und gedreht werden können.
     
 <details>
      <summary>Bildergalerie</summary>
      
## Abgedichtetes Thermometer
      
<b>Bild des abgedichteten Thermometers von der Seite</b> <img alt="Bild von der Seite" src="https://user-images.githubusercontent.com/88385654/143951400-061ec319-9c3c-4a9c-b14b-2301cc4b7ea5.jpg">
<b> Bild des abgedichteten Thermometers von schräg vorne </b> <img alt="Bild von schräg vorne" src="https://user-images.githubusercontent.com/88385654/143951423-04f56437-1700-4f00-accf-d948e08f4083.jpg">
<b> Bild des abgedichteten Thermometers von oben </b> <img alt="Bild von schräg vorne" src="https://user-images.githubusercontent.com/88385654/143951440-b116fed3-dbb4-4f71-b4c8-6c4def6827fb.jpg">
      
## integriertes Thermometer im Topfdeckel
      
<b>Bild des integrierten Thermometers von oben</b> <img alt="Bild von oben" src="https://user-images.githubusercontent.com/88385654/144057917-1ea3bb3b-d948-4542-9d92-c1e9a11e1be2.jpg">
<b>Bild des integrierten Thermometers von unten</b> <img alt="Bild von unten" src="https://user-images.githubusercontent.com/88385654/144058112-2b5efc09-a4c1-40ea-b612-869629e68002.jpg">
<b>Bild des integrierten Thermometers von der Seite</b> <img alt="Bild von der Seite" src="https://user-images.githubusercontent.com/88385654/144058239-6dc095ea-86f8-4bc0-ac1b-776fa384bd0b.jpg">
      
</details>

## <p> <h2> <a id="Stundevom1.12.2021"> Stunde vom 1.12.2021 </a> <h2>
Die Hardware wurde zwischen dem 30.11-1.12 fertiggestellt. In der Werkstatt zu Hause wurde gebastelt, getüftelt und geplant. Ein zurechtgeschnittetes Blech wurde mit einer Öffnung versehen, sodass es sich um das Ventil des Gaskochers legt. Durch einen steckmechanismus wurde die Grundplatte noch weiter befestigt. Damit der Schrittmotor befestigt werden kann, wurden Löcher in die Grundplatte geborht und verschraubt. Mit Winkeln wurde eine Verlängerung von Grundplatte zu Schrittmotor hergestellt, sodass der Motor gut befestigt war. Durch die vielen Schraubverbindungen in den Winkeln ist eine gewisse Flexibilität der Halterung gegeben. Diese Beweglichkeit ist essenziell, da der Regler der Gasflasche auf einem Gewinde befindet und sich daher, je nach Öffnungsstand nach vorne, bzw. hinten bewegt. Auch die korrekte Ausrichtung wird durch die vielen "Gelenke" gegenüber einer starren Verbindung mit einer Stange erleichtert. <br>
In dieser Stunde wurde die Projektseite weiter mit Leben gefüllt. Dafür wurden für die vorher geplanten Kategorien Texte geschrieben. Die Einleitung in das Physical Computing Projekt wurden gegeben und die Grundlagen des Arduino erklärt. Außerdem wurden Texte über die Idde, die Gruppe und die verwendeten Programme geschrieben. Die Finalisierung des Projekts soll nun bis zum Wochenende abgeschlossen werden, damit das Wochenende als Puffer zur Verfügung steht und eventuell noch auftretende Probleme gelöst werden können. Die Gruppe freut sich auf die Abgabe am 6.12.2021. 
   
<details>
	<summary>Bildergalerie</summary>
<b> Befestigung von der Seite </b> <img alt="Konstruktion von der Seite" src="https://user-images.githubusercontent.com/88385654/144402384-15489c91-9107-455a-bc8b-5d53066fb09b.jpg">
<b> Befestigung von schräg oben</b><img src="https://user-images.githubusercontent.com/88385654/144402395-d7157686-69d8-4adc-98be-19945850cf96.jpg">
<b> Bestigung von oben<b/> <img src="https://user-images.githubusercontent.com/88385654/144402404-a9837b5f-8883-48e4-87cb-64d848cb62a6.jpg">
<b>Befestigung von hinten</b><img src="https://user-images.githubusercontent.com/88385654/144402410-ca4a9371-f19a-40ca-87f2-3fa1e6008d9b.jpg">
<b>Befestigung von vorne</b><img src="https://user-images.githubusercontent.com/88385654/144402415-13314859-2691-4073-9b42-42bdc00a1e1b.jpg">
<b>Installation des Schrittmotors auf die Gasflasche von schräg vorne</b><img src="https://user-images.githubusercontent.com/88385654/144403416-7cae2da2-8f27-4c75-9266-59e114b70b39.jpg">
<b>Installation des Schrittmotors auf die Gasflasche von schräg oben</b><img src="https://user-images.githubusercontent.com/88385654/144403476-cb159229-fa66-4257-ae6e-4cb33aec5960.jpg">
<b>gesamter Aufbau der Hardware</b><img src="https://user-images.githubusercontent.com/88385654/144403510-b2791893-3fbc-4e86-b2cc-caa792264d9e.jpg">

</details>
	
<details>
     <summary> erste Struktur der Projektseite </summary>
     
<code>
<html>
<head>
<h1 align="center">Der arduinogesteuerte Gaskocher - Projektseite</h1> 
</head>
<h3 align="center"> Ein Projekt von David Borgmann und Simon Rettmann</h3>
<h3 align="left">Stormarnschule Ahrensburg <br/> Informatik, Bl <br/> Schuljahr 2021/22, 1. Halbjahr <br/> </h3> </div>
	     
<hr>

<h3>Navigation</h3>

<b>1. Grundlagen</b>	

<ul>
	<li> <a href="#Team"> Das Team </a> </li>
	<li> <a href="#Arduino"> Der Arduino - Grundlage des Physical Computing Projekts </a> </li>
	<li> <a href="#Programme"> Verwendete Programme </a> </li>
	<li> <a href="#Lernprozess"> Erlenen der benötigten Fähigkeiten </a> </li>
</ul>

<b>2. Das Projekt</b>	

<ul>
	<li> <a href="#Idee"> Die Idee </a> </li> 
	<li> <a href="#Entwicklungsgeschichte"> Entwicklungsgeschichte </a> </li>
	<li> <a href="#Software"> softwaretechnische Umsetzung </a> </li> 
	<li> <a href="#Hardware"> hardwaretechnische Umsetzung </a> </li>
</ul>

<b>3. Reflexion</b>

<ul>
	<li> <a href="#Reflexion"> Reflexion und Fazit des Projektes </a> </li>
</ul>

<hr>

<a id="Team"> <h4> 1️⃣ Das Team</a> </h4>
Für dieses Halbjahresprojekt im Rahmen des Informatikunterricht, schlossen sich David Borgmann und Simon Rettmann zu einem Team zusammen. Als gute 		Freunde bildeten sie ein gut funktionierendes Team aus Entwicklern, das das Projekt unbedingt nach vorne bringen wollten. Beide besaßen aufgrund einer 		Teilnahme am Enrichement-Kurs "Das Programmieren von Microcontrollern" schon ein paar Arduinovorkenntnisse. Beigeistert ist die Gruppe vor allem von 		Physical Computing Projekten, weil es ermöglicht Hardware und Software zu vereinen. Somit kann im Kopf und Computer etwas gesteuert und erschaffen 		werden, was in der realen Welt tatsächlich funktioniert. Diese Art von Projekten fasziniert die Beiden. 

<h4> <a id="Arduino"> 1️⃣ Der Arduino - Grundlage des Physical Computing Projekts</a> </h4>
Bei dem arduinogesteuertem Gaskocher handelt es sich um ein Physical Computing Projekt. Das bedeutet, dass Anwendungen der Informatik in Wechselwirkung mit der Umwelt stehen. Dazu ist sowohl Hardware, welche mit der physischen Umwelt im Kontakt steht, als auch Software, welche die Hardware interaktiv 	mit „Leben“ füllt, nötig. Arduino bietet bei diesem Projekt die Plattform, welche die Umsetztung des Projektes ermöglicht. Arduino ist eine aus Soft- 	und Hardware bestehende open-source Physical Computing-Plattform. 
Das Herzstück der Hardware ist dabei der Micro-Controller, in diesem Fall der Arduino UNO R3. Bei dem UNO handelt es sich um das Standard-Modell des 	Repertoires. Dieser ist günstig und für viele Projekte im Bezug auf Rechenleistung, Speicher und Anschlussmöglichkeiten völlig ausreichend.
Programmiert wird der Microcontroller mithilfe der integrierten Entwicklungsumgebung. Es handelt sich um eine plattformübergreifende Anwendung. Die 	Programmiersprache beinhaltet Elemente aus C, C++ und AVR-Assembler und der Code lässt sich von einem Computer mithilfe eines USB-Anschlusses auf den 	UNO übertragen.

<h4> <a id="Programme"> 1️⃣ Verwendete Programme</a> </h4>
Zur präzisen Umsetzung und ansprechenden Dokumentation wurde eine Vielzahl von verschiedenen Programmen benutzt und dessen Handhabung erlernt.

<ul>
	<li>Arduino IDE</li>
	Der Arduino stellt das Herzstück des Projektes dar. In der Entwicklungsoberfläche wurde das Programm geschrieben und auf den Arduino Uno 			gespielt.
		 
<details>
	<summary>Entwicklungsoberfläche von Arduino</summary>
		<img alt="Entwicklungsoberfläche" width="1792" src="https://user-images.githubusercontent.com/88385654/144110935-967a7811-2b7d-47cb-				ab8c-9f44b3a6a83d.png">
	<a href="https://www.arduino.cc"> - Website von Arduino</a>
		
</details>
	
<li>GitHub</li>
	GitHub ist eine Software zur Versionsverwaltung von Software. Für dieses Projekt wurde GitHub für die Dokumentation genutzt, um 				Stundenprotokolle, eine Art Tagebuch für jede Stunde, und eine Projektseite, eine Zusammenfassung des Halbjahresprojektes, zu erstellen. 
	
<details>
	<summary>Oberfläche von GitHub</summary>
	<img alt="GitHub" width="1792" src="https://user-images.githubusercontent.com/88385654/144112129-7995500f-9060-49eb-b976-9301c159ab12.png">
	<a href="https://github.com/"> - Website von GitHub</a>
	
</details>
	
<li>fritzing</li>
	Fritzing wurde genutzt, um die für die Hardware erforderlichen Steckverbindungen und eingesetzten Geräte, zu digitalisieren.
	
<details>
	<summary>Oberfläche von fritzing</summary>
	<img alt="fritzing" width="1792" src="https://user-images.githubusercontent.com/88385654/144112753-0cdef113-cc82-46a9-89f8-d3e3018bf087.png">
	<a href="https://fritzing.org/"> - Website von fritzing </a>
	
</details>	
	
<li>TinkerCAD</li>
	TinkerCAD ist eine Software, mit der 3-D Objekte modelliert werden können. Für das Projekt war es wichtig, eine Steckverbindung zwischen 			Gaskocher und Schrittmotor herzustellen. Ein dementsprechendes 3-D Modell wurde erstellt und als .stl Datei exportiert.

<details>
	<summary>Oberfläche von TincerCAD</summary>
	<img width="1792" alt="Obefläche von TinkerCAD" src="https://user-images.githubusercontent.com/88385654/144115179-eeff862f-5fa8-4073-aad6-			471d0d160e06.png">
	<a href="https://www.tinkercad.com/things/58xIQMAeis5-sizzling-curcan/edit"> - Oberfläche von TinkerCAD</a>

</details>
	
<li>Cura</li>
	Die mit TinkerCAD erstellte .stl Datei kann mit Hilfe der Software Cura in einen .gcode umgewandelt werden. Dieser Dateityp ist mit 3-D Druckern 		kompatibel. So wurde das auf TinkerCAD erstellte Modell, nach Anpassung der Druckeinstellungen, gedruckt. 
	
<details>
	<summary>Oberfläche von Cura</summary>
	<img width="1792" alt="Oberfläche von Cura" src="https://user-images.githubusercontent.com/88385654/144115541-6deae014-7fc5-4551-8e25-				75105fe808ac.png">
	<a href="https://ultimaker.com/de/software/ultimaker-cura"> - Website von Cura</a>
	
</details>
	
</ul>


<h4> <a id="Lernprozess"> 1️⃣ Erlenen der benötigten Fähigkeiten</a> </h4>

<hr>

<h4> <a id="Idee"> 2️⃣ Die Idee</a> </h4>

<details>
	<summary>Mehr Infos</summary>

Die Entwickler des Projektes, David und Simon, sind begeisterte Outdoor-Fans. In den Sommerferien eine Woche "Wildcampen" in Schweden und eine 		Studienfahrt, in der eine Woche auf der Mecklenburger-Seenplatte Kanu gefahren wurde. Neben der Natur begeistert allerdings auch das Kochen die Beiden. So kam es bei der Nahrungszubereitung bei diesen beiden Urlauben zu Problemen: Mal ist der Gaskocher zu heiß-der Reis angebrannt, mal das Wasser zu kalt - die Nudeln werden einfach nicht gar. Als in der Einführung zum Informatikunterricht die Möglichkeit eines "Physical-Computing"-Projekts genannt wurde und zuerst einige Ideen diskutiert wurden, entschieden sich die beiden schnell für einen aurdionogesteuerten Gaskocher. Die Idee für das Projekt war 	geboren. Ziel war es einen Gaskocher so steuern zu können, dass eine vorher eingestellte Temperatur erreicht und selbstständig gehalten werden kann.
</details>

<h4> <a id="Entwicklungsgeschichte"> 2️⃣ Entwicklungsgeschichte</a> </h4>

<h4> <a id="Software"> 2️⃣ softwaretechnische Umsetzung </a> </h4>

<h4> <a id="Hardware"> 2️⃣ hardwaretechnische Umsetzung </a> </h4>

<h4> <a id="Reflexion"> 3️⃣ Reflexion und Fazit des Projekts </a> </h4>

</code>
</details>
	
## <a id="Finalisierung"> Finalisierung vom 1.12.2021 - 6.12.2021 </a>

Während dieser finalten Phase wurden Testungen durchgeführt, um mögliche Probleme zu finden und zu behenben. Erfreulich war zu sehen, dass sowohl die Hardware als auch die Software ihren Zweck erfüllten und den Kern des Projektes erfüllten. Allerdings traten bei diesen Versuchen auch Unstimmigkeiten auf, die zu Problemen führte. 
<ul>
	<li> Bei einem Test, in dem die Temperatur auf 80 °C eingestellt wurde, erreichte der Gaskocher mehr als 90 °C. Das lag daran, dass der Gaskocher zu spät die Flamme reduzierte und die Sparflamme ausreichte, um das Wasser im Topf weiter zu erwärmen. Es gab dementsprechend keinen ausgeglichenen Zustand aus Erwärumen und Abgabe der Temperatur an die Umwelt. Somit wurde die Temperatur nicht gehalten, sondern langsam erhöht. <a href="<https://youtu.be/qgBPvEuJ_uI">Video zu dem Probeversuch</a>
		
<source src="https://youtu.be/qgBPvEuJ_uI" type="video/mp4">
<iframe width="560" height="315" src="https://www.youtube.com/embed/qgBPvEuJ_uI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
